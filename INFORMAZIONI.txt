 Avviato Powershell come amministratore
Installazione Chocolatey: gestore pacchetti windows
Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))

Installazione node(che contiene il gestore pacchetti npm, python e java development kit)
choco install -y nodejs.install python2 jdk8

npm install -g react-native-cli

installazione Android Studio
Impostazione variabile di ambiente utente ANDROID_HOME: C:\Users\graziano.spinelli\AppData\Local\Android\Sdk

Installazione da Android Studio -> Tools -> SDK

Android 8.0 (Oreo) ->
Android SDK Platform 26
Google APIs Intel x86 Atom_64 System Image

Impostato sul Cell USB x trasferimento file, Attivato sul cell USB Debugging da Impostazioni->Sistema->Opzioni Sviluppatore, collegato tramite USB, controllato il collegamento con:
C:\users\utente\appdata\Local\Android\sdk\platform-tools\adb devices

Su linux adb server deve essere lanciato da root per vedere i dispositivi:
sudo adb kill-server
sudo adb start-server

Lanciata la creazione di una nuova applicazione con:
react-native init NewProject

cd C:\Users\graziano.spinelli\NewProject
Lanciare in un terminale Amministratore il Metro Bundler (gira sulla porta 8081) dalla cartella project con:
react-native start --reset-cache
Attendere il messaggio:
Loading dependency graph, done.

In un altro terminale:
cd C:\Users\graziano.spinelli\NewProject
react-native run-android

L'applicazione sul telefono non parte.
Per risolvere parte del problema lanciare sul PC di sviluppo:
adb.exe reverse tcp:8081 tcp:8081 

Sulla macchina di sviluppo la porta 8081 è occupata allora lanciamo Metro Bundler sulla porta 8088, sempre stando nella cartella Progetto:
react-native start --reset-cache --port=8088

sull'altro terminale:
adb.exe reverse tcp:8088 tcp:8088
react-native run-android

Bisogna configurare la nuova porta anche sull'app nel telefono:
mentre l'applicazione nel telefono è aperta bisogna shackerare il telefono.
Nel menù che compare scegliere: Debugging -> Debug server host & port for device
Inserire: localhost:8088

Fare il Reload dal menù.

Una volta disconnesso il cellulare, per ripristinare la connessione la volta successiva, 
bisogna avere il server JS Metro Bundler attivo in un terminale amministratore e in un altro terminale lanciare:
adb.exe reverse tcp:8088 tcp:8088

Per l'installazione di nuove librerie il Metro Bundler deve essere disattivato e i file in edit tutti chiusi,
altrimenti l'installazione non va a buon fine.
Ogni volta che si installano nuove librerie nella App
- disinstallare dal Cellulare
- Lanciare nel Terminale Amministratore: 
  react-native start --reset-cache --port=8088
- Lanciare nel terminale utente, nella cartella progetto: 
  adb.exe reverse tcp:8088 tcp:8088
  react-native run-android
- Riconfigurare l'app sul cellulare con localhost:8088 in Debugging -> Debug server host & port for device
__________________________________________________________________________________________

JSX - a syntax for embedding XML within JavaScript.
Many frameworks use a special templating language which lets you embed code inside markup language. In React, this is reversed. JSX lets you write your markup language inside code. It looks like HTML on the web, except instead of web things like <div> or <span>, you use React components. In this case, <Text> is a built-in component that just displays some text and View is like the <div> or <span>.

import React, { Component } from 'react';
import { Text, View } from 'react-native';

export default class HelloWorldApp extends Component {
  render() {
    return (
      <View>
        <Text>Hello world!</Text>
      </View>
    );
  }
}

this code is defining HelloWorldApp, a new Component. When you're building a React Native app, you'll be making new components a lot. Anything you see on the screen is some sort of component. A component can be pretty simple - the only thing that's required is a render function.

Most components can be customized when they are created, with different parameters. These creation parameters are called props. 

one basic React Native component is the Image. When you create an image, you can use a prop named source to control what image it shows.

let pic = {
      uri: 'https://cinepop.com.br/wp-content/uploads/2017/10/thor4_1-750x380.jpg'
};
return (
      <Image source={pic} style={{width: 193, height: 290}}/>
);

{pic} is surrounded by braces, to embed the variable pic into JSX. You can put any JavaScript expression inside braces in JSX.

There are two types of data that control a component: props and state. props are set by the parent and they are fixed throughout the lifetime of a component. For data that is going to change, we have to use state.
The state is mutable while props are immutable. This means that state can be updated in the future while props cannot be updated.

In general, you should initialize state in the constructor, and then call setState when you want to change it.
When setState is called, the App will re-render its Component.
You can also use a state container like Redux or Mobx to control your data flow. In that case you would use Redux or Mobx to modify your state rather than calling setState directly.

With React Native, you don't use a special language or syntax for defining styles. You just style your application using JavaScript. All of the core components accept a prop named style. The style names and values usually match how CSS works on the web
StyleSheet.create define several styles in one place:

<Text style={styles.bigblue}>just bigblue</Text>

const styles = StyleSheet.create({
  bigblue: {
    color: 'blue',
    fontWeight: 'bold',
    fontSize: 30,
  },
});

The simplest way to set the dimensions of a component is by adding a fixed width and height to style
<View>
        <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />
        <View style={{width: 150, height: 150, backgroundColor: 'steelblue'}} />
</View>

_______________________________________________________________________________

ES6 ci offre numerose feature interessanti. Ne elenco solo alcune tra quelle che considero più utili:

- Classi: finalmente viene introdotto il concetto di classe che consente di introdurre la programmazione orientata agli oggetti nel codice JavaScript; ne faremo uso scrivendo componenti React ereditando una classe della libreria (Component).
- Variabili in scope locali: grazie alla parola chiave let possiamo dichiarare variabili che siano locali all’interno del blocco di codice in cui sono dichiarati, per intenderci quello delimitato da parentesi graffe { e }, restringendo quindi la visibilità dello scope rispetto a quelli disponibili nel classico JavaScript quando si utilizza la parola chiave var, ovvero quello globale e quello locale alla funzione.
- Funzioni lambda: grazie all’operatore => possiamo creare funzioni lambda come avviene già in molti altri linguaggi, rendendo il codice più sintetico ed essenziale.
- Moduli: la suddivisione del codice in moduli consente di creare ambiti dai quali è possibile esportare tipi affinché siano visibili all’esterno del modulo corrente, ossia accessibili da altri moduli, dai quali è invece possibile importare dei tipi. Faremo uso di questa funzionalità per esportare componenti React dai nostri script importando la classe base fornita dalla libreria React, dalla quale si deve ereditare per creare un nuovo componente. Questa feature è essenziale per tool di pacchettizzazione come WebPack, che sfrutta questa sintassi per determinare le dipendenze tra i moduli e assemblare il codice opportunamente.

FUNZIONI FRECCIA JAVASCRIPT (Funzioni Lambda)

function square(x) {
  return x * x;
}

Abbiamo la parola chiave function poi le parentesi graffe che raccolgono il corpo della funzione.
In JS possiamo assegnare la nostra funzione ad una variabile con una sintassi di questo tipo:

var square = function(x) {
  return x * x;
};

Vediamo ora come cambia la sintassi con le funzioni freccia:

x => { return x * x }  // block

possiamo scrivere il costrutto anche in altro modo

x => x * x    // omettiamo anche il return

Esempio:
[1,2,3].map(x => 2 * x)  //[ 2, 4, 6 ]

PASSAGGIO DEI PARAMETRI:
() => { ... } // no parameter
x => { ... } // one parameter, an identifier
(x, y) => { ... } // several parameters
_________________________________________________________________________________________________

Firebase Cloud Messaging, formerly known as Google Cloud Messaging, is a cross-platform cloud solution for messages and notifications for Android, iOS, and web applications, which currently can be used at no cost. The service is provided by Firebase, a subsidiary of Google.
________________________________________________________________________________________________

Nel file package.json sono elencate tutte le dipendenze dell'applicazione
infatti quando installiamo nuovi componenti con npm, automaticamente compaiono elencati nel file package.
______________________________________________________________________________________________

Per la navigazione tra le schermate dell'applicazione e le icone da utilizzare:

Navigation:
Once we have those five screens set up, we can get the first part of our navigation created — the tab navigation at the bottom of the screen. We’re going to be using the React Navigation library. 
We’ll add a router.js file to the root of our app folder and then install a couple of libraries:

npm install react-navigation --save

e la libreria React Native Elements for icons & such: react-native-elements .

Per gestire le schermate di una App si può usare anche: react-native-router-flux
Nella cartelle della App dare da terminale il comando:
npm install react-native-router-flux --save

Le librerie vanno a finire nella cartella .\node-modules della App e viene aggiornato il file package.json in cui sono raccolte tutte le dipendenze.
L'opzione --save è quella che va ad aggiornare le dipendenze in package.json
_________________________________________________________________________________________

Per implementare una chat installiamo il componente:

npm install react-native-gifted-chat --save
_________________________________________________________________________

Per user le prop-types:
npm install --save prop-types

e nel codice:
import PropTypes from 'prop-types';
__________________________________________________________________________

Per creare animazioni:

l'animazine viene creata in Adobe After Effects ed implementata nell'App con Lottie.
- Si installa in After Effect Bodymovin:
Bodymovin is a plugin for After Effects that can export animation in json data format for Lottie to use.
- Si installa una libreria per React-Native:
npm i --save lottie-react-native

- Si utilizza nel codice:
import React from 'react';
import LottieView from 'lottie-react-native';

export default class BasicExample extends React.Component {
  render() {
    return (
      <LottieView
        source={require('./animation.json')}
        autoPlay
        loop
      />
    );
  }
}

__________________________________________________________________________

FUNZIONI CALLBACK

Le funzioni di un linguaggio di programmazione, come Javascript, consentono di passare come parametro non solo dei valori di tipo variabile o costante, ma anche altre funzioni che prenderanno il nome di funzioni di callback (in italiano funzioni di richiamo). Tali funzioni di callback, in genere (anche dato il nome "callback"), vengono eseguite dopo la routine principale, quindi al termine dell'esecuzione primaria lanciata dalla funzione chiamante.

Lo scopo delle funzioni di callback è quello di consentire a funzioni specifiche di svolgere comiti ulteriori a quelli loro propri, compiti che normalmente non sono noti al momento della scrittura del codice della funzione principale. In pratica si tratta di una tecnica (tipica della programmazione funzionale) grazie alla quale è possibile "espandere" le funzionalità predefinite di un blocco di codice, lasciando allo sviluppatore una maggiore libertà di sviluppo pur mantenendo un elevato grado di "riutilizzo" del codice sorgente.

Guardiamo un basilare esempio sintattico:


function esempio(parametro, callback) {
  
  
}

La nostra funzione di esempio ha un parametro (potrebbe averne più di uno) e, in ultimo, un altro parametro che chiameremo callback, non perchè sia obbligatorio chiamarlo così, bensì per convenzione. 
La "funzione nella funzione" può essere opzionale o meno, a seconda di come viene controllata, ma in ogni caso sarà richiamata o direttamente definita all'interno del richiamo alla funzione principale, come nel seguente esempio di utilizzo:


function foo() {
  
}




esempio("Valore del parametro...", foo);

oppure:


esempio("Valore del parametro...", function() {
  
});

La nostra prima callback

Facciamo un esempio concreto, programmando una semplice funzione che mostra una alert col nome dell'utente e che consente anche di gestire un'eventuale funzione come ultimo parametro:

function saluto(nome, cognome, callback) {
  alert('Ciao ' + nome + ' ' + cognome);
  if (callback && typeof callback === 'function') callback();
}

Nella nostra funzione di esempio abbiamo tre parametri, due stringhe ("nome" e "cognome") e l'ultimo parameto la funzione di richiamo, opzionale, monitorata attraverso la seguente funzione di controllo:

if (callback && typeof callback === 'function') callback();

Con questo controllo verifichiamo per prima cosa la presenza del parametro "callback", quindi verifichiamo che si tratti di una funzione (utilizzando il comando typeof e verificando che il valore sia function). Se la condizione passa, utilizziamo il nome del parametro aggiungendo le parentesi tonde aperta e chiusa per "trasformare" il parametro in funzione.

Potremmo quindi richiamare la funzione in modo semplice:

saluto('Mario', 'Rossi');

ottenendo semplicemente un alert con scritto:

Ciao Mario Rossi

oppure potremmo creare una funzione di richiamo al suo interno:

saluto('Mario', 'Rossi', function() {
  alert('Sei il benvenuto!');
});

ottenendo come risultato un secondo alert con scritto:

Sei il benvenuto!

In questo modo le due funzioni vengono eseguite in sequenza, nel senso che la nostra callback verrà lanciata non appena terminata l'istruzione primaria che la precede.
Gestire correttamente le temporizzazioni e le chiamate asincrone

Abbiamo detto che lo scopo di una funzione di callback è di essere eseguita, solitamente, dopo la routine principale. In merito a questa osservazione è necessario fare una puntualizzazione: ciò non è sempre vero quando si ha a che fare con delle temporizzazioni o con delle chiamate asincrone (Ajax). Facciamo un esempio.

function temporizzazione(ritardo, callback) {
  window.setTimeout(function() {
    document.write("Scusate il ritardo!");
  }, ritardo);
  if (callback && typeof callback === "function") callback();
}

In questo caso la routine principale è gestita mediante una temporizzazione che prevede un ritardo, pertanto Javascript passerà immediatamente (cioè senza attendere questo ritardo) all'istruzione successiva. In questo caso, quindi, la nostra funzione di cakkback verrà eseguita prima della principale.

Lo sviluppatore che predispone la funzione principale, pertanto, deve avere l'attenzione di gestire correttamente eventuali problemi legati ai tempi di esecuzione delle istruzioni. Per risolvere il problema, ad esempio, sarebbe stato sufficiente inserire il richiamo alla callback direttamente all'interno del metodo setTimeout in questo modo:

function temporizzazione(ritardo, callback) {
  window.setTimeout(function() {
    document.write("Scusate il ritardo!");
    if (callback && typeof callback === "function") callback();
  }, ritardo);
}

Così facendo, infatti, viene ripristinato l'ordine delle cose, in quanto il ritardo di esecuzione riguarderà tanto l'istruzione principale quanto la funzione di callback che, pertanto, tornerà ad essere l'ultimo blocco di esecuzione.

Lo stesso discorso va fatto se si utilizzano chiamate asincrone (Ajax): anche in questo caso, infatti, è opportuno inserire la funzione di calback all'interno del blocco logico che verifica la completa esecuzione ed il successo della chiamata, in caso contrario si potrebbero generare anomalie nel flusso di esecuzione del codice come quelle viste nell'esempio riguardante la cattiva gestione della temporizzazione.

function ajax(risorsa, callback) {
  var requestObj = false;
  if (window.XMLHttpRequest) {
    requestObj = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    requestObj = new ActiveXObject("Microsoft.XMLHTTP");
  }
  requestObj.open("GET", risorsa);
  requestObj.onreadystatechange = function () {
    if (requestObj.readyState == 4 && requestObj.status == 200) {
      alert(requestObj.responseText);
      if (callback && typeof callback === "function") callback();
    }
  }
  requestObj.send(null);
}

Passare il risultato della funzione principale alla funzione di callback

Vediamo infine come passare il valore elaborato dalla prima routine alla nostra funzione di callback in modo tale che quest'ultima possa effettuare operazioni sul risultato della funzione chiamante. Vediamo un esempio:

function somma(a,b,callback) {
  var risultato = (a + b);
  if (callback && typeof callback === "function") {
    risultato = callback(risultato);
  }
  return risultato;  
}

Come potete notare, in questa funzione effettuo il solito controllo per vedere se è stata prevista una funzione di callback ed in caso affermativo ne lancio l'esecuzione passandogli, come parametro, il risultato della routine principale (il risultato della somma di a + b). In questo caso la nostra funzione di callback assegnerà un nuovo valore alla variabile "risultato" alternado, di fatto, il valore di ritorno dalla funzione chiamante.

A questo punto il codice per richiamare la nostra funzione potrebbe essere qualcosa del genere:

var numero = somma(5,3,function(n) {
  return (n*n);
});
document.write(numero);

Con questa semplice funzione di callback prendiamo il valore ottenuto dalla somma di 5+3 (cioè 8) e lo eleviamo al quadrato (facciamo cioè 8x8) ottenendo come risultato 64.

Se la funzione di callbak non viene implementata direttamente nel codice di richiamo ma è esterna, il passaggio di parametri diviene più complicato. Non è possibile, infatti, richiamare direttamente la funzione di callback ma è necessario utilizzare "un intermediario" in questo modo:


function quadrato(n) {
  return (n*n);    
}



var numero = somma(5,3,function(n) {
  return quadrato(n)    
});

________________________________________________________________________________________________________________

Le funzioni callback sono diventate uno dei concetti basi da conoscere se si vuole diventare uno sviluppatore JavaScript. Infatti il linguaggio JavaScript è fortemente basato sul concetto delle funzioni callback.
In concetti di programmazione funzionale ci sono parole come  funzioni anonime e callback.

Prima di parlare di funzioni anonime e callback paliamo di come funziona normalmente una funzione in JavaScript.

Prendiamo questa funzione esempio: (mi dispiace se odiate i gatti :/ ce ne saranno un po’ in questo post)


var mostra_gatti = function(gatto){
    console.log(gatto);
}
mostra_gatti("Romeo");

Come sapete questa funzione prende come input una Stringa e la mostra in output nella console, come farebbe una normale funzione.
Ma il linguaggio JavaScript ci da l’occasione di fare le cose in modo diverso. Infatti in JS anziché aspettare che una funzione finisca di fare il suo lavoro, possiamo usare le funzioni di callback per lavorare in modo asincrono.

Cosa vuol dire lavorare in modo asincrono?

Una funzione asincrona non blocca il nostro codice JS (Browser). In altre parole se eseguiamo una funzione asincrona, questa lavorerà nel background del nostro programma principale. In questo modo possiamo usare funzioni pesanti che possono impiegare tanto tempo (per esempio funzioni AJAX), senza bloccare altri eventi JavaScript.

Adesso immaginiamo di non avere a disposizione una lista dei gatti, dovremo quindi fare una richiesta ad un server per ricevere la lista dei nostri amati felini.

Se immaginiamo di avere una lista molto grande, oppure una lista di gatti generata dinamicamente, la risposta dal server potrebbe impiegare molto tempo per raggiungere il nostro client.

E se la nostra funzione è sincrona, questa come una vera diva, bloccherà tutto finche non ha completato il suo lavoro, mettendo in pausa il resto. Durante questo periodo non sarà possibile alcuna interazione Client – JS

Per evitare che questo accada useremo quindi una funzione asincrona per ottenere la nostra lista.

Cosa sono le funzioni callback in JavaScript?

Le funzioni in JavaScript sono veri e propri Oggetti, questo vuol dire che godono delle stesse proprietà di cui godono le comuni variabili JS. Possiamo quindi passare una funzione come parametro di un’altra funzione.

Per esempio in JavaScript è possibile fare:

var mostra_gatti = function(){…}
var prendi_gatti = function(callback);
prendi_gatti(mostra_gatti); // passiamo prendi_gatti come parametro di mostra_gatti

In questo esempio stiamo chiamando una funzione dichiarata. (Non anonima)

Possiamo fare la stessa cosa utilizzando funzioni anonime, ovvero funzioni dichiarate nello stesso momento in cui vengono utilizzate. Ora vediamo lo stesso programma utilizzando una funzione anonima.

var prendi_gatti = function(callback){…};
prendi_gatti( function(){…} );

Ma se la nostra funzione è in esecuzione in background, Il problema che ci sorge è come facciamo a sapere quando la funzione ha finito ed è pronta per stampare la lista dei gatti?
Come usare le funzioni callback in JavaScript

Ecco dove entrano in gioco le funzioni callback. Infatti quando passiamo una funzione come parametro, possiamo specificare con precisione in che momento vogliamo mandarla in esecuzione.

Nel nostro caso quindi vogliamo mandare in output la nostra lista solamente quando riceviamo una risposta dal server.

Vediamo come: 

// in questo esempio facciamo una richiesta GET al nostro server e eseguiamo la nostra callback quando riceviamo una risposta dal server
var prendi_gatti = function(callback){
    var xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function() {
        if (xmlHttp.readyState == 4 && xmlHttp.status == 200) // quando riceviamo una risposta
        callback(xmlHttp.responseText);
    }
    xmlHttp.open("GET", "www.prendiGatti.com", true); // true per asincrona
    xmlHttp.send(null);
}
var mostra_gatti = function(gatti){
    console.log(gatti);
}
prendi_gatti(mostra_gatti);

oppure utilizzando una funzione anonima:

// in questo esempio facciamo una richiesta GET al nostro server e eseguiamo la nostra callback quando riceviamo una risposta dal server
var prendi_gatti = function(callback){
    var xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function() {
        if (xmlHttp.readyState == 4 && xmlHttp.status == 200) // quando riceviamo una risposta
        callback(xmlHttp.responseText);
    }
    xmlHttp.open("GET", "www.prendiGatti.com", true); // true per asincrona
    xmlHttp.send(null);
}
prendi_gatti(function(gatti){
    console.log(gatti);
});

Se mandiamo in esecuzione questo codice JavaScript otterremo una lista di gatti senza bloccare il browser nel processo.
_____________________________________________________________________________________________

Nella programmazione web, un polyfill (o polyfiller) è del codice scaricabile che fornisce dei servizi che non fanno parte di un browser web. 
Esso implementa tecnologie che uno sviluppatore si aspetta il browser metta a disposizione nativamente, fornendo un ventaglio più uniforme di API. 
Ad esempio, molte caratteristiche di HTML5 non sono supportate da versioni di Internet Explorer precedenti la 8, ma possono essere utilizzate dalle pagine web se queste installano un polyfill. 
Webshim e HTML5 Shivs sono concetti correlati. 

_____________________________________________________________________________________________

Analogie tra HTML e React Native

HTML		React Native
-----------	----------------------
div 		View
img 		Image
span, p 	Text
ul/ol, li 	ListView, child items

_____________________________________________________________________________________________

https://learn.handlebarlabs.com/p/react-native-basics-build-a-currency-converter
User: 

_________________________________________________________________________

Inviare Dati da Mobile React-Native a PHP POST
import FormData from 'FormData';

let formData = new FormData();
formData.append('username', 'Graziano');

let data = {
    method: 'POST',
    headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
    },
    body: formData
}

fetch(api_url, data)
.then(response => response.json())
.then(responseJson => console.log('response:', responseJson))
.catch(error => console.error(error));


I dati che si vuole inviare sono: 
username=Graziano
___________________________________________________________________

INSTALLAZIONE ALGORITMO SHA265
npm install --save react-native-sha256
react-native link

USO:
import { sha256 } from 'react-native-sha256';


sha256("Test").then( hash => {console.log(hash);})

___________________________________________________________________

Installato VSCode
Installata Estensione ESLint dentro VSCode
da terminale di VSCode installato globalmente eslint:
npm install -g eslint
Sempre da terminale nella cartella progetto digitiamo:
eslint --init
? How would you like to configure ESLint? Use a popular style guide
? Which style guide do you want to follow? Airbnb (https://github.com/airbnb/javascript)
? Do you use React? Yes
? What format do you want your config file to be in? JavaScript

__________________________________________________________

Redux Form, formik, unstate, reactN per eliminare redux

_____________________________________

ISTRUZIONI GIT:

CREATE A BRANCH:
Dalla command palette: git branch

per tornare indietro:
git checkout master

Per andare dinuovo nel branch futuro:
git checkout e selezioniamo il nome del branch futuro

Possiamo pubblicare sul repository remoto in cloud:
git publish

Per aggiungere repository remoto

Creare repository su github, poi: 
git remote add origin https://...
git remote show origin <- funziona se tutto ok
su VS compare la nuvoletta in basso a SX

git push -u origin master # assumendo siamo sul master branch.
oppure clicchiamo la nuvoletta 

Quando ci sono cambiamenti sull'icona git appare un badge numerico

Cliccare sull'icona e decidere quali cambiamenti si vogliono cliccando sul + (stage) oppure sull'undo.

una volta decisi i cambiamenti si puo cliccare sul segno di spunta che è il commit dando un nome al cambiamento

per tornare indietro click su ... e poi Undo Last Commit
























